Код Гре́я — двоичный код, иначе зеркальный код, он же код с отражением, в котором две «соседние» (в упорядоченном, то есть лексикографическом, наборе) кодовые комбинации различаются только цифрой в одном двоичном разряде. Иными словами, расстояние Хэмминга между соседними кодовыми комбинациями равно 1.
Наиболее часто на практике применяется рефлексивный двоичный код Грея, хотя в общем случае существует бесконечное множество кодов Грея со значениями цифр в разрядах, взятых из различных алфавитов. В большинстве случаев, под термином «код Грея» понимают именно рефлексивный бинарный код Грея.
Изначально предназначался для защиты от ложного срабатывания электромеханических переключателей. Сегодня коды Грея широко используются для упрощения выявления и исправления ошибок в системах связи, а также в формировании сигналов обратной связи в системах управления.

Название
Код Грея назван «рефлексивным» (отражённым) из-за того, что первая половина значений при изменении порядка эквивалентна второй половине, за исключением старшего бита. Старший бит просто инвертируется. При делении каждой новой половины пополам это свойство сохраняется (см. самоподобие).
Код назван в честь исследователя Фрэнка Грея, работавшего в лаборатории «Bell labs». Грей запатентовал (патент № 2632058) и впервые использовал этот код в своей импульсной системе связи.

Применения
Код Грея используется в передаче меняющихся цифровых сигналов в отсутствие тактового сигнала синхронизации (например, во многих видах датчиков). Представим себе, что код (обычный двоичный) перескакивает 3→4, или 0112 → 1002. Если из-за несовершенства считывателя мы прочитаем первый бит от 011, а остальные два — от 100, мы получим 0002=0 — число, далёкое от реальных значений. В коде Грея никаких посторонних значений не будет: перескок будет в одном разряде, 010G → 110G, и мы считаем либо старое 010G=3, либо новое 110G=4.
Если считыватель настолько медленный, что за время считывания показания несколько раз сменились, код Грея гарантирует, что ошибка будет невелика — меньше, чем реальное изменение сигнала. Например, если за время считывания показания сменились 010G=3 → 110G → 111G=5, то помимо этих трёх значений, можно получить 011G=2 — выходит ошибка на единицу.
Если датчик круговой (например, угловой энкодер), то ему приходится перескакивать и с максимума до нуля. Такой перескок (с 100G=7 до 000G=0) тоже изменяет один разряд.

Коды Грея часто используются в датчиках-энкодерах. Их использование удобно тем, что два соседних значения шкалы сигнала отличаются только в одном разряде. Также они используются для кодирования номера дорожек в жёстких дисках.
Код Грея можно использовать также и для решения задачи о Ханойских башнях.
Широко применяются коды Грея и в теории генетических алгоритмов для кодирования генетических признаков, представленных целыми числами.
Код Грея используется для генерации сочетаний методом двери-вертушки.
В некоторых компьютерных играх (например, Duke Nukem 3D) для успешного прохождения уровня требуется подобрать нужную комбинацию положений нескольких переключателей. Никаких подсказок нет, надо просто перебрать все комбинации. Для минимизации числа переключений при переборе вариантов следует использовать код Грея. Например, если переключателей три, пробуем их в порядке 000, 001, 011, 010, 110…
Сложные датчики, требующие синхросигнала, отходят от кода Грея и работают в обычном двоичном.

Алгоритмы преобразования
Преобразование двоичного кода в код Грея
Коды Грея легко получаются из двоичных чисел путём побитовой операции «Исключающее ИЛИ» с тем же числом, сдвинутым вправо на один бит и в котором старший разряд заполняется нулём. Следовательно, i-й бит кода Грея Gi выражается через биты двоичного кода Bi следующим образом:

  
    
      
        
          G
          
            i
          
        
        =
        
          B
          
            i
          
        
        ⊕
        
          B
          
            i
            +
            1
          
        
        ,
      
    
    {\displaystyle G_{i}=B_{i}\oplus B_{i+1},}
  
где 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   — операция «исключающее ИЛИ»; биты нумеруются справа налево, начиная с младшего.
Ниже приведён алгоритм преобразования из двоичной системы счисления в код Грея, записанный на языке C:

Однако, необходимо помнить, что данный алгоритм будет работать правильно, если компилятор реализует нециклический логический сдвиг (например, стандарт языка C не уточняет тип сдвига для знаковых чисел, но для unsigned типов поддержка гарантируется).
Тот же самый алгоритм, записанный на языке Паскаль:

Пример: преобразовать двоичное число 10110 в код Грея.

10110
01011
----- XOR
11101

Преобразование кода Грея в двоичный код
Обратный алгоритм — преобразование кода Грея в двоичный код — можно выразить рекуррентной формулой

  
    
      
        
          B
          
            i
          
        
        =
        
          B
          
            i
            +
            1
          
        
        ⊕
        
          G
          
            i
          
        
        ,
      
    
    {\displaystyle B_{i}=B_{i+1}\oplus G_{i},}
  
причём преобразование осуществляется побитно, начиная со старших разрядов, и значение 
  
    
      
        
          B
          
            i
            +
            1
          
        
      
    
    {\displaystyle B_{i+1}}
  , используемое в формуле, вычисляется на предыдущем шаге алгоритма. Действительно, если подставить в эту формулу вышеприведённое выражение для i-го бита кода Грея, получим

  
    
      
        
          B
          
            i
          
        
        =
        
          B
          
            i
            +
            1
          
        
        ⊕
        
          G
          
            i
          
        
        =
        
          B
          
            i
            +
            1
          
        
        ⊕
        (
        
          B
          
            i
          
        
        ⊕
        
          B
          
            i
            +
            1
          
        
        )
        =
        
          B
          
            i
          
        
        ⊕
        (
        
          B
          
            i
            +
            1
          
        
        ⊕
        
          B
          
            i
            +
            1
          
        
        )
        =
        
          B
          
            i
          
        
        ⊕
        0
        =
        
          B
          
            i
          
        
        .
      
    
    {\displaystyle B_{i}=B_{i+1}\oplus G_{i}=B_{i+1}\oplus (B_{i}\oplus B_{i+1})=B_{i}\oplus (B_{i+1}\oplus B_{i+1})=B_{i}\oplus 0=B_{i}.}
  
Однако приведённый алгоритм, связанный с манипуляцией отдельными битами, неудобен для программной реализации, поэтому на практике используют видоизменённый алгоритм:

  
    
      
        
          B
          
            k
          
        
        =
        
          ⨁
          
            i
            =
            k
          
          
            N
          
        
        
          G
          
            i
          
        
        ,
      
    
    {\displaystyle B_{k}=\bigoplus \limits _{i=k}^{N}G_{i},}
  
где N — число битов в коде Грея (для увеличения быстродействия алгоритма в качестве N можно взять номер старшего ненулевого бита кода Грея); знак 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   означает суммирование при помощи операции «исключающее ИЛИ», то есть

  
    
      
        
          ⨁
          
            i
            =
            k
          
          
            N
          
        
        
          G
          
            i
          
        
        =
        
          G
          
            k
          
        
        ⊕
        
          G
          
            k
            +
            1
          
        
        ⊕
        .
        .
        .
        ⊕
        
          G
          
            N
            −
            1
          
        
        ⊕
        
          G
          
            N
          
        
        .
      
    
    {\displaystyle \bigoplus \limits _{i=k}^{N}G_{i}=G_{k}\oplus G_{k+1}\oplus ...\oplus G_{N-1}\oplus G_{N}.}
  
Действительно, подставив в формулу выражение для i-го бита кода Грея, получим

  
    
      
        
          B
          
            k
          
        
        =
        
          ⨁
          
            i
            =
            k
          
          
            N
          
        
        
          G
          
            i
          
        
        =
        
          ⨁
          
            i
            =
            k
          
          
            N
          
        
        (
        
          B
          
            i
          
        
        ⊕
        
          B
          
            i
            +
            1
          
        
        )
        =
        (
        
          B
          
            k
          
        
        ⊕
        
          B
          
            k
            +
            1
          
        
        )
        ⊕
        (
        
          B
          
            k
            +
            1
          
        
        ⊕
        
          B
          
            k
            +
            2
          
        
        )
        ⊕
        .
        .
        .
        ⊕
        (
        
          B
          
            N
            −
            1
          
        
        ⊕
        
          B
          
            N
          
        
        )
        ⊕
        (
        
          B
          
            N
          
        
        ⊕
        
          B
          
            N
            +
            1
          
        
        )
        =
      
    
    {\displaystyle B_{k}=\bigoplus \limits _{i=k}^{N}G_{i}=\bigoplus \limits _{i=k}^{N}(B_{i}\oplus B_{i+1})=(B_{k}\oplus B_{k+1})\oplus (B_{k+1}\oplus B_{k+2})\oplus ...\oplus (B_{N-1}\oplus B_{N})\oplus (B_{N}\oplus B_{N+1})=}
  

  
    
      
        =
        
          B
          
            k
          
        
        ⊕
        (
        
          B
          
            k
            +
            1
          
        
        ⊕
        
          B
          
            k
            +
            1
          
        
        )
        ⊕
        .
        .
        .
        ⊕
        (
        
          B
          
            N
          
        
        ⊕
        
          B
          
            N
          
        
        )
        ⊕
        
          B
          
            N
            +
            1
          
        
        =
        
          B
          
            k
          
        
        ⊕
        
          B
          
            N
            +
            1
          
        
        =
        
          B
          
            k
          
        
      
    
    {\displaystyle =B_{k}\oplus (B_{k+1}\oplus B_{k+1})\oplus ...\oplus (B_{N}\oplus B_{N})\oplus B_{N+1}=B_{k}\oplus B_{N+1}=B_{k}}
  
Здесь предполагается, что бит, выходящий за рамки разрядной сетки (
  
    
      
        
          B
          
            N
            +
            1
          
        
      
    
    {\displaystyle B_{N+1}}
  ), равен нулю.
Ниже приведена функция на языке С, реализующая данный алгоритм. Она осуществляет последовательный сдвиг вправо и суммирование исходного двоичного числа, до тех пор, пока очередной сдвиг не обнулит слагаемое.

Тот же самый алгоритм, записанный на языке Паскаль:

Пример: преобразовать код Грея 11101 в двоичный код.

11101
01110
00111
00011
00001
-----
10110

Быстрое преобразование 8/16/24/32-разрядного значения кода Грея в двоичный код на языке C (Примечание: исходный код Грея является составным. Где каждая тетрада бит является отдельным числом и закодирована отдельно. Этот код не является полноценным кодом Грея. И правило изменения одного бита при переходе к новому числу сохраняется только в пределах каждой четвёрки. Например при переходе от 0x0F к 0x10 изменяются одновременно два бита так как мы имеем изменение двух тетрад 0->1 и F->0):

Простой способ преобразования двоичного числа в код Грея выполняется по правилу: старший разряд записывается без изменения, каждый следующий символ кода Грея нужно инвертировать, если в натуральном коде перед этим была получена «1», и оставить без изменения, если в натуральном коде был получен «0».

Генерация кодов Грея
Код Грея для n бит может быть рекурсивно построен на основе кода для n-1 бит путём переворачивания списка бит (то есть записыванием кодов в обратном порядке), конкатенации исходного и перевёрнутого списков, дописывания нулей в начало каждого кода в исходном списке и единиц — в начало кодов в перевёрнутом списке. Так, для генерации списка для n = 3 бит на основании кодов для двух бит необходимо выполнить следующие шаги:

Ниже представлен один из алгоритмов создания последовательности кода Грея заданной глубины, записанный на языке Perl:

Рекурсивная функция построения кода Грея на языке C:

Быстрое преобразование 8/16/24/32-разрядного двоичного кода в код Грея на языке C. (Примечание: полученный код не является полноценным кодом Грея. Данный код преобразовывает в код Грея каждые 4 бита отдельно, рассматривая их как отдельные числа. В результате полученный код состоит из множества 4 битных кодов грея. И правило изменения одного бита при переходе к новому числу сохраняется только в пределах каждой четвёрки. Например при переходе от 0x0F к 0x10 изменяются одновременно два бита так как мы имеем изменение двух тетрад 0->1 и F->0):

Необычные вариации кода Грея
Сбалансированный код Грея
Если датчики имеют ограниченный ресурс по количеству переключений, хотелось бы, чтобы они изнашивались равномерно. В сбалансированном коде Грея в разных разрядах количество переключений настолько близко, насколько можно.

0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 0
0 0 1 1 1 1 0 0 1 1 1 1 0 0 0 0 
0 0 0 0 1 1 1 1 1 0 0 1 1 1 0 0 
0 0 0 1 1 0 0 0 0 0 1 1 1 1 1 1

Здесь в 4-битном коде каждый разряд переключается четырежды. В 5-битном коде такое невозможно, приходится переключать один бит 8 раз, остальные — по 6.

Однодорожечный код Грея
Код Грея является однодорожечным, если все столбцы матрицы являются кольцевыми сдвигами друг друга. Это позволяет сделать угловой датчик с одной дорожкой.
Двухбитный код Грея является однодорожечным, это можно увидеть в компьютерной мыши — как в шариковом механизме старых мышей, так и в колесе прокрутки новых. Два датчика стоят в разных точках одной дорожки. Если довести эту систему до крайности — половина диска «чёрная», половина «белая», и датчики стоят на 90° друг относительно друга — то можно узнать абсолютное положение диска с дискретностью в 90°.
Для кодов Грея более высокой разрядности это не так, приходится увеличивать количество дорожек, это делает датчик громоздким и дорогим. Поэтому, если возможно, обходятся двумя дорожками — одна для двухбитного кода Грея, и одна — позиция нуля. Однако существуют коды, где дорожка именно одна, правда, все 2n позиций так закодировать невозможно. Для 5 бит рекорд — 30 позиций, для 9 — 360.

Двухмерный код Грея
Используется в квадратурной модуляции сигналов. Соседние точки «созвездия» отличаются одним битом, диагональные — двумя.

См. также
Код Хэмминга
Код Джонсона
Код Рида — Соломона

Примечания
Литература
Black, Paul E. Gray code. 25 февраля 2004. NIST. [1] (англ.)

Ссылки
NIST Dictionary of Algorithms and Data Structures: Gray code (англ.)
Коды Грея (рус.)